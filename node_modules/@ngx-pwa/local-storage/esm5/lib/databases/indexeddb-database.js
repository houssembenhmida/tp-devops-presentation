/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable, Optional, Inject } from '@angular/core';
import { ReplaySubject, fromEvent, of, throwError, race } from 'rxjs';
import { map, mergeMap, first, tap } from 'rxjs/operators';
import { LocalStorageDatabase } from './localstorage-database';
import { LOCAL_STORAGE_PREFIX } from '../tokens';
import * as i0 from "@angular/core";
import * as i1 from "../tokens";
var IndexedDBDatabase = /** @class */ (function () {
    /**
     * Connects to IndexedDB
     */
    function IndexedDBDatabase(prefix) {
        if (prefix === void 0) { prefix = null; }
        this.prefix = prefix;
        /**
         * IndexedDB database name for local storage
         */
        this.dbName = 'ngStorage';
        /**
         * IndexedDB object store name for local storage
         */
        this.objectStoreName = 'localStorage';
        /**
         * IndexedDB key path name for local storage (where an item's key will be stored)
         */
        this.keyPath = 'key';
        /**
         * IndexedDB data path name for local storage (where items' value will be stored)
         */
        this.dataPath = 'value';
        /**
         * IndexedDB is available but failing in some scenarios (Firefox private mode, Safari cross-origin iframes),
         * so a fallback can be needed.
         */
        this.fallback = null;
        if (prefix) {
            this.dbName = prefix + "_" + this.dbName;
        }
        /* Creating the RxJS ReplaySubject */
        this.database = new ReplaySubject();
        /* Connecting to IndexedDB */
        this.connect(prefix);
    }
    Object.defineProperty(IndexedDBDatabase.prototype, "size", {
        get: /**
         * @return {?}
         */
        function () {
            var _this = this;
            /* Fallback storage if set */
            if (this.fallback) {
                return this.fallback.size;
            }
            return this.transaction('readonly').pipe(mergeMap(function (transaction) {
                /* Deleting the item in local storage */
                /** @type {?} */
                var request = transaction.count();
                /** @type {?} */
                var success = ((/** @type {?} */ (fromEvent(request, 'success')))).pipe(map(function (event) { return (/** @type {?} */ (((/** @type {?} */ (event.target))).result)); }));
                /* Merging success and errors events and autoclosing the observable */
                return ((/** @type {?} */ (race(success, _this.toErrorObservable(request, "length")))));
            }), first());
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets an item value in local storage
     * @param key The item's key
     * @returns The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
     */
    /**
     * Gets an item value in local storage
     * @template T
     * @param {?} key The item's key
     * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
     */
    IndexedDBDatabase.prototype.getItem = /**
     * Gets an item value in local storage
     * @template T
     * @param {?} key The item's key
     * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
     */
    function (key) {
        /* Fallback storage if set */
        if (this.fallback) {
            return this.fallback.getItem(key);
        }
        /* Opening a trasaction and requesting the item in local storage */
        return this.getItemFromTransaction(key);
    };
    /**
     * Internal method to factorize the getter for getItem and setItem,
     * the last one needing to be from a preexisting transaction
     * @param key The item's key
     * @param transactionParam Optional pre-existing transaction to use for the read request
     * @returns The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
     */
    /**
     * Internal method to factorize the getter for getItem and setItem,
     * the last one needing to be from a preexisting transaction
     * @private
     * @template T
     * @param {?} key The item's key
     * @param {?=} transactionParam Optional pre-existing transaction to use for the read request
     * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
     */
    IndexedDBDatabase.prototype.getItemFromTransaction = /**
     * Internal method to factorize the getter for getItem and setItem,
     * the last one needing to be from a preexisting transaction
     * @private
     * @template T
     * @param {?} key The item's key
     * @param {?=} transactionParam Optional pre-existing transaction to use for the read request
     * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
     */
    function (key, transactionParam) {
        var _this = this;
        /** @type {?} */
        var transaction$ = transactionParam ? of(transactionParam) : this.transaction();
        return transaction$.pipe(map(function (transaction) { return transaction.get(key); }), mergeMap(function (request) {
            /* Listening to the success event, and passing the item value if found, null otherwise */
            /** @type {?} */
            var success = ((/** @type {?} */ (fromEvent(request, 'success')))).pipe(map(function (event) { return ((/** @type {?} */ (event.target))).result; }), map(function (result) { return result && (_this.dataPath in result) ? ((/** @type {?} */ (result[_this.dataPath]))) : null; }));
            /* Merging success and errors events and autoclosing the observable */
            return (race(success, _this.toErrorObservable(request, "getter")));
        }), first());
    };
    /**
     * Sets an item in local storage
     * @param key The item's key
     * @param data The item's value, must NOT be null or undefined
     * @returns An RxJS Observable to wait the end of the operation
     */
    /**
     * Sets an item in local storage
     * @param {?} key The item's key
     * @param {?} data The item's value, must NOT be null or undefined
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    IndexedDBDatabase.prototype.setItem = /**
     * Sets an item in local storage
     * @param {?} key The item's key
     * @param {?} data The item's value, must NOT be null or undefined
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    function (key, data) {
        var _this = this;
        /* Fallback storage if set */
        if (this.fallback) {
            return this.fallback.setItem(key, data);
        }
        /* Storing null is not correctly supported by IndexedDB and unnecessary here */
        if (data == null) {
            return of(true);
        }
        /* Transaction must be the same for read and write, to avoid concurrency issues */
        /** @type {?} */
        var transaction$ = this.transaction('readwrite');
        /** @type {?} */
        var transaction;
        /* Opening a transaction */
        return transaction$.pipe(tap(function (value) {
            transaction = value;
        }), 
        /* Check if the key already exists or not */
        mergeMap(function () { return _this.getItemFromTransaction(key, transaction); }), map(function (existingData) { return (existingData == null) ? 'add' : 'put'; }), mergeMap(function (method) {
            var _a, _b;
            /** @type {?} */
            var request;
            /* Adding or updating local storage, based on previous checking */
            switch (method) {
                case 'add':
                    request = transaction.add((_a = {}, _a[_this.dataPath] = data, _a), key);
                    break;
                case 'put':
                default:
                    request = transaction.put((_b = {}, _b[_this.dataPath] = data, _b), key);
                    break;
            }
            /* Merging success (passing true) and error events and autoclosing the observable */
            return (race(_this.toSuccessObservable(request), _this.toErrorObservable(request, "setter")));
        }), first());
    };
    /**
     * Deletes an item in local storage
     * @param key The item's key
     * @returns An RxJS Observable to wait the end of the operation
     */
    /**
     * Deletes an item in local storage
     * @param {?} key The item's key
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    IndexedDBDatabase.prototype.removeItem = /**
     * Deletes an item in local storage
     * @param {?} key The item's key
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    function (key) {
        var _this = this;
        /* Fallback storage if set */
        if (this.fallback) {
            return this.fallback.removeItem(key);
        }
        /* Opening a transaction and checking if the item exists in local storage */
        return this.getItem(key).pipe(mergeMap(function (data) {
            /* If the item exists in local storage */
            if (data != null) {
                /* Opening a transaction */
                return _this.transaction('readwrite').pipe(mergeMap(function (transaction) {
                    /* Deleting the item in local storage */
                    /** @type {?} */
                    var request = transaction.delete(key);
                    /* Merging success (passing true) and error events and autoclosing the observable */
                    return (race(_this.toSuccessObservable(request), _this.toErrorObservable(request, "remover")));
                }));
            }
            /* Passing true if the item does not exist in local storage */
            return of(true);
        }), first());
    };
    /**
     * Deletes all items from local storage
     * @returns An RxJS Observable to wait the end of the operation
     */
    /**
     * Deletes all items from local storage
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    IndexedDBDatabase.prototype.clear = /**
     * Deletes all items from local storage
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    function () {
        var _this = this;
        /* Fallback storage if set */
        if (this.fallback) {
            return this.fallback.clear();
        }
        /* Opening a transaction */
        return this.transaction('readwrite').pipe(mergeMap(function (transaction) {
            /* Deleting all items from local storage */
            /** @type {?} */
            var request = transaction.clear();
            /* Merging success (passing true) and error events and autoclosing the observable */
            return (race(_this.toSuccessObservable(request), _this.toErrorObservable(request, "clearer")));
        }), first());
    };
    /**
     * @return {?}
     */
    IndexedDBDatabase.prototype.keys = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /* Fallback storage if set */
        if (this.fallback) {
            return this.fallback.keys();
        }
        return this.transaction('readonly').pipe(mergeMap(function (transaction) {
            /* Deleting the item in local storage */
            /** @type {?} */
            var request = transaction.getAllKeys();
            /** @type {?} */
            var success = ((/** @type {?} */ (fromEvent(request, 'success')))).pipe(map(function (event) { return (/** @type {?} */ (((/** @type {?} */ (event.target))).result)); }));
            /* Merging success and errors events and autoclosing the observable */
            return (race(success, _this.toErrorObservable(request, "keys")));
        }), first());
    };
    /**
     * @param {?} key
     * @return {?}
     */
    IndexedDBDatabase.prototype.has = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        var _this = this;
        /* Fallback storage if set */
        if (this.fallback) {
            return this.fallback.has(key);
        }
        return this.transaction('readonly').pipe(map(function (transaction) { return transaction.getKey(key); }), mergeMap(function (request) {
            /* Listening to the success event, and passing the item value if found, null otherwise */
            /** @type {?} */
            var success = ((/** @type {?} */ (fromEvent(request, 'success')))).pipe(map(function (event) { return ((/** @type {?} */ (event.target))).result; }), map(function (result) { return (result !== undefined) ? true : false; }));
            /* Merging success and errors events and autoclosing the observable */
            return (race(success, _this.toErrorObservable(request, "has")));
        }), first());
    };
    /**
     * Connects to IndexedDB and creates the object store on first time
     */
    /**
     * Connects to IndexedDB and creates the object store on first time
     * @protected
     * @param {?=} prefix
     * @return {?}
     */
    IndexedDBDatabase.prototype.connect = /**
     * Connects to IndexedDB and creates the object store on first time
     * @protected
     * @param {?=} prefix
     * @return {?}
     */
    function (prefix) {
        var _this = this;
        if (prefix === void 0) { prefix = null; }
        /** @type {?} */
        var request;
        /* Connecting to IndexedDB */
        try {
            request = indexedDB.open(this.dbName);
        }
        catch (error) {
            /* Fallback storage if IndexedDb connection is failing */
            this.setFallback(prefix);
            return;
        }
        /* Listening the event fired on first connection, creating the object store for local storage */
        ((/** @type {?} */ (fromEvent(request, 'upgradeneeded'))))
            .pipe(first())
            .subscribe(function (event) {
            /* Getting the database connection */
            /** @type {?} */
            var database = (/** @type {?} */ (((/** @type {?} */ (event.target))).result));
            /* Checking if the object store already exists, to avoid error */
            if (!database.objectStoreNames.contains(_this.objectStoreName)) {
                /* Creating the object store for local storage */
                database.createObjectStore(_this.objectStoreName);
            }
        });
        /* Listening the success event and converting to an RxJS Observable */
        /** @type {?} */
        var success = (/** @type {?} */ (fromEvent(request, 'success')));
        /* Merging success and errors events */
        ((/** @type {?} */ (race(success, this.toErrorObservable(request, "connection")))))
            .pipe(first())
            .subscribe(function (event) {
            /* Storing the database connection for further access */
            _this.database.next((/** @type {?} */ (((/** @type {?} */ (event.target))).result)));
        }, function () {
            /* Fallback storage if IndexedDb connection is failing */
            _this.setFallback(prefix);
        });
    };
    /**
     * Opens an IndexedDB transaction and gets the local storage object store
     * @param mode Default to 'readonly' for read operations, or 'readwrite' for write operations
     * @returns An IndexedDB transaction object store, wrapped in an RxJS Observable
     */
    /**
     * Opens an IndexedDB transaction and gets the local storage object store
     * @protected
     * @param {?=} mode Default to 'readonly' for read operations, or 'readwrite' for write operations
     * @return {?} An IndexedDB transaction object store, wrapped in an RxJS Observable
     */
    IndexedDBDatabase.prototype.transaction = /**
     * Opens an IndexedDB transaction and gets the local storage object store
     * @protected
     * @param {?=} mode Default to 'readonly' for read operations, or 'readwrite' for write operations
     * @return {?} An IndexedDB transaction object store, wrapped in an RxJS Observable
     */
    function (mode) {
        var _this = this;
        if (mode === void 0) { mode = 'readonly'; }
        /* From the IndexedDB connection, opening a transaction and getting the local storage objet store */
        return this.database
            .pipe(map(function (database) { return database.transaction([_this.objectStoreName], mode).objectStore(_this.objectStoreName); }));
    };
    /**
     * Transforms a IndexedDB success event in an RxJS Observable
     * @param request The request to listen
     * @returns A RxJS Observable with true value
     */
    /**
     * Transforms a IndexedDB success event in an RxJS Observable
     * @protected
     * @param {?} request The request to listen
     * @return {?} A RxJS Observable with true value
     */
    IndexedDBDatabase.prototype.toSuccessObservable = /**
     * Transforms a IndexedDB success event in an RxJS Observable
     * @protected
     * @param {?} request The request to listen
     * @return {?} A RxJS Observable with true value
     */
    function (request) {
        /* Transforming a IndexedDB success event in an RxJS Observable with true value */
        return ((/** @type {?} */ (fromEvent(request, 'success'))))
            .pipe(map(function () { return true; }));
    };
    /**
     * Transforms a IndexedDB error event in an RxJS ErrorObservable
     * @param request The request to listen
     * @param error Optionnal details about the error's origin
     * @returns A RxJS ErrorObservable
     */
    /**
     * Transforms a IndexedDB error event in an RxJS ErrorObservable
     * @protected
     * @param {?} request The request to listen
     * @param {?=} error Optionnal details about the error's origin
     * @return {?} A RxJS ErrorObservable
     */
    IndexedDBDatabase.prototype.toErrorObservable = /**
     * Transforms a IndexedDB error event in an RxJS ErrorObservable
     * @protected
     * @param {?} request The request to listen
     * @param {?=} error Optionnal details about the error's origin
     * @return {?} A RxJS ErrorObservable
     */
    function (request, error) {
        if (error === void 0) { error = ""; }
        /* Transforming a IndexedDB error event in an RxJS ErrorObservable */
        return ((/** @type {?} */ (fromEvent(request, 'error'))))
            .pipe(mergeMap(function () { return throwError(new Error("IndexedDB " + error + " issue : " + ((/** @type {?} */ (request.error))).message + ".")); }));
    };
    /**
     * @protected
     * @param {?} prefix
     * @return {?}
     */
    IndexedDBDatabase.prototype.setFallback = /**
     * @protected
     * @param {?} prefix
     * @return {?}
     */
    function (prefix) {
        this.fallback = new LocalStorageDatabase(prefix);
    };
    IndexedDBDatabase.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    IndexedDBDatabase.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LOCAL_STORAGE_PREFIX,] }] }
    ]; };
    /** @nocollapse */ IndexedDBDatabase.ngInjectableDef = i0.defineInjectable({ factory: function IndexedDBDatabase_Factory() { return new IndexedDBDatabase(i0.inject(i1.LOCAL_STORAGE_PREFIX, 8)); }, token: IndexedDBDatabase, providedIn: "root" });
    return IndexedDBDatabase;
}());
export { IndexedDBDatabase };
if (false) {
    /**
     * IndexedDB database name for local storage
     * @type {?}
     * @protected
     */
    IndexedDBDatabase.prototype.dbName;
    /**
     * IndexedDB object store name for local storage
     * @type {?}
     * @protected
     */
    IndexedDBDatabase.prototype.objectStoreName;
    /**
     * IndexedDB key path name for local storage (where an item's key will be stored)
     * @type {?}
     * @protected
     */
    IndexedDBDatabase.prototype.keyPath;
    /**
     * IndexedDB data path name for local storage (where items' value will be stored)
     * @type {?}
     * @protected
     */
    IndexedDBDatabase.prototype.dataPath;
    /**
     * IndexedDB database connection, wrapped in a RxJS ReplaySubject to be able to access the connection
     * even after the connection success event happened
     * @type {?}
     * @protected
     */
    IndexedDBDatabase.prototype.database;
    /**
     * IndexedDB is available but failing in some scenarios (Firefox private mode, Safari cross-origin iframes),
     * so a fallback can be needed.
     * @type {?}
     * @protected
     */
    IndexedDBDatabase.prototype.fallback;
    /**
     * @type {?}
     * @protected
     */
    IndexedDBDatabase.prototype.prefix;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXhlZGRiLWRhdGFiYXNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG5neC1wd2EvbG9jYWwtc3RvcmFnZS8iLCJzb3VyY2VzIjpbImxpYi9kYXRhYmFzZXMvaW5kZXhlZGRiLWRhdGFiYXNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDN0QsT0FBTyxFQUFjLGFBQWEsRUFBRSxTQUFTLEVBQUUsRUFBRSxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDbEYsT0FBTyxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRzNELE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQy9ELE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLFdBQVcsQ0FBQzs7O0FBRWpEO0lBMERFOztPQUVHO0lBQ0gsMkJBQWdFLE1BQTRCO1FBQTVCLHVCQUFBLEVBQUEsYUFBNEI7UUFBNUIsV0FBTSxHQUFOLE1BQU0sQ0FBc0I7Ozs7UUFyRGxGLFdBQU0sR0FBRyxXQUFXLENBQUM7Ozs7UUFJWixvQkFBZSxHQUFHLGNBQWMsQ0FBQzs7OztRQUlqQyxZQUFPLEdBQUcsS0FBSyxDQUFDOzs7O1FBSWhCLGFBQVEsR0FBRyxPQUFPLENBQUM7Ozs7O1FBVTVCLGFBQVEsR0FBeUIsSUFBSSxDQUFDO1FBaUM5QyxJQUFJLE1BQU0sRUFBRTtZQUVWLElBQUksQ0FBQyxNQUFNLEdBQU0sTUFBTSxTQUFJLElBQUksQ0FBQyxNQUFRLENBQUM7U0FFMUM7UUFFRCxxQ0FBcUM7UUFDckMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLGFBQWEsRUFBZSxDQUFDO1FBRWpELDZCQUE2QjtRQUM3QixJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lB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LGlCQUFZLENBQUMsbUJBQUEsT0FBTyxDQUFDLEtBQUssRUFBZ0IsQ0FBQyxDQUFDLE9BQU8sTUFBRyxDQUFDLENBQUMsRUFBL0YsQ0FBK0YsQ0FBQyxDQUNoSCxDQUFDO0lBRU4sQ0FBQzs7Ozs7O0lBRVMsdUNBQVc7Ozs7O0lBQXJCLFVBQXNCLE1BQXFCO1FBQ3pDLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxvQkFBb0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNuRCxDQUFDOztnQkFqWkYsVUFBVSxTQUFDO29CQUNWLFVBQVUsRUFBRSxNQUFNO2lCQUNuQjs7OztnREEyRGMsUUFBUSxZQUFJLE1BQU0sU0FBQyxvQkFBb0I7Ozs0QkFyRXREO0NBMlpDLEFBblpELElBbVpDO1NBaFpZLGlCQUFpQjs7Ozs7OztJQUs1QixtQ0FBK0I7Ozs7OztJQUkvQiw0Q0FBb0Q7Ozs7OztJQUlwRCxvQ0FBbUM7Ozs7OztJQUluQyxxQ0FBc0M7Ozs7Ozs7SUFLdEMscUNBQStDOzs7Ozs7O0lBSy9DLHFDQUFnRDs7Ozs7SUErQnBDLG1DQUFnRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIE9wdGlvbmFsLCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFJlcGxheVN1YmplY3QsIGZyb21FdmVudCwgb2YsIHRocm93RXJyb3IsIHJhY2UgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCwgbWVyZ2VNYXAsIGZpcnN0LCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IExvY2FsRGF0YWJhc2UgfSBmcm9tICcuL2xvY2FsLWRhdGFiYXNlJztcbmltcG9ydCB7IExvY2FsU3RvcmFnZURhdGFiYXNlIH0gZnJvbSAnLi9sb2NhbHN0b3JhZ2UtZGF0YWJhc2UnO1xuaW1wb3J0IHsgTE9DQUxfU1RPUkFHRV9QUkVGSVggfSBmcm9tICcuLi90b2tlbnMnO1xuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290J1xufSlcbmV4cG9ydCBjbGFzcyBJbmRleGVkREJEYXRhYmFzZSBpbXBsZW1lbnRzIExvY2FsRGF0YWJhc2Uge1xuXG4gIC8qKlxuICAgKiBJbmRleGVkREIgZGF0YWJhc2UgbmFtZSBmb3IgbG9jYWwgc3RvcmFnZVxuICAgKi9cbiAgcHJvdGVjdGVkIGRiTmFtZSA9ICduZ1N0b3JhZ2UnO1xuICAvKipcbiAgICogSW5kZXhlZERCIG9iamVjdCBzdG9yZSBuYW1lIGZvciBsb2NhbCBzdG9yYWdlXG4gICAqL1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgb2JqZWN0U3RvcmVOYW1lID0gJ2xvY2FsU3RvcmFnZSc7XG4gIC8qKlxuICAgKiBJbmRleGVkREIga2V5IHBhdGggbmFtZSBmb3IgbG9jYWwgc3RvcmFnZSAod2hlcmUgYW4gaXRlbSdzIGtleSB3aWxsIGJlIHN0b3JlZClcbiAgICovXG4gIHByb3RlY3RlZCByZWFkb25seSBrZXlQYXRoID0gJ2tleSc7XG4gIC8qKlxuICAgKiBJbmRleGVkREIgZGF0YSBwYXRoIG5hbWUgZm9yIGxvY2FsIHN0b3JhZ2UgKHdoZXJlIGl0ZW1zJyB2YWx1ZSB3aWxsIGJlIHN0b3JlZClcbiAgICovXG4gIHByb3RlY3RlZCByZWFkb25seSBkYXRhUGF0aCA9ICd2YWx1ZSc7XG4gIC8qKlxuICAgKiBJbmRleGVkREIgZGF0YWJhc2UgY29ubmVjdGlvbiwgd3JhcHBlZCBpbiBhIFJ4SlMgUmVwbGF5U3ViamVjdCB0byBiZSBhYmxlIHRvIGFjY2VzcyB0aGUgY29ubmVjdGlvblxuICAgKiBldmVuIGFmdGVyIHRoZSBjb25uZWN0aW9uIHN1Y2Nlc3MgZXZlbnQgaGFwcGVuZWRcbiAgICovXG4gIHByb3RlY3RlZCBkYXRhYmFzZTogUmVwbGF5U3ViamVjdDxJREJEYXRhYmFzZT47XG4gIC8qKlxuICAgKiBJbmRleGVkREIgaXMgYXZhaWxhYmxlIGJ1dCBmYWlsaW5nIGluIHNvbWUgc2NlbmFyaW9zIChGaXJlZm94IHByaXZhdGUgbW9kZSwgU2FmYXJpIGNyb3NzLW9yaWdpbiBpZnJhbWVzKSxcbiAgICogc28gYSBmYWxsYmFjayBjYW4gYmUgbmVlZGVkLlxuICAgKi9cbiAgcHJvdGVjdGVkIGZhbGxiYWNrOiBMb2NhbERhdGFiYXNlIHwgbnVsbCA9IG51bGw7XG5cbiAgZ2V0IHNpemUoKTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcblxuICAgIC8qIEZhbGxiYWNrIHN0b3JhZ2UgaWYgc2V0ICovXG4gICAgaWYgKHRoaXMuZmFsbGJhY2spIHtcbiAgICAgIHJldHVybiB0aGlzLmZhbGxiYWNrLnNpemU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb24oJ3JlYWRvbmx5JykucGlwZShcbiAgICAgIG1lcmdlTWFwKCh0cmFuc2FjdGlvbikgPT4ge1xuXG4gICAgICAgIC8qIERlbGV0aW5nIHRoZSBpdGVtIGluIGxvY2FsIHN0b3JhZ2UgKi9cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRyYW5zYWN0aW9uLmNvdW50KCk7XG5cbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9IChmcm9tRXZlbnQocmVxdWVzdCwgJ3N1Y2Nlc3MnKSBhcyBPYnNlcnZhYmxlPEV2ZW50PikucGlwZShcbiAgICAgICAgICBtYXAoKGV2ZW50KSA9PiAoZXZlbnQudGFyZ2V0IGFzIElEQlJlcXVlc3QpLnJlc3VsdCBhcyBudW1iZXIpLFxuICAgICAgICApO1xuXG4gICAgICAgIC8qIE1lcmdpbmcgc3VjY2VzcyBhbmQgZXJyb3JzIGV2ZW50cyBhbmQgYXV0b2Nsb3NpbmcgdGhlIG9ic2VydmFibGUgKi9cbiAgICAgICAgcmV0dXJuIChyYWNlKHN1Y2Nlc3MsIHRoaXMudG9FcnJvck9ic2VydmFibGUocmVxdWVzdCwgYGxlbmd0aGApKSBhcyBPYnNlcnZhYmxlPG51bWJlcj4pO1xuXG4gICAgICB9KSxcbiAgICAgIGZpcnN0KClcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogQ29ubmVjdHMgdG8gSW5kZXhlZERCXG4gICAqL1xuICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBASW5qZWN0KExPQ0FMX1NUT1JBR0VfUFJFRklYKSBwcm90ZWN0ZWQgcHJlZml4OiBzdHJpbmcgfCBudWxsID0gbnVsbCkge1xuXG4gICAgaWYgKHByZWZpeCkge1xuXG4gICAgICB0aGlzLmRiTmFtZSA9IGAke3ByZWZpeH1fJHt0aGlzLmRiTmFtZX1gO1xuXG4gICAgfVxuXG4gICAgLyogQ3JlYXRpbmcgdGhlIFJ4SlMgUmVwbGF5U3ViamVjdCAqL1xuICAgIHRoaXMuZGF0YWJhc2UgPSBuZXcgUmVwbGF5U3ViamVjdDxJREJEYXRhYmFzZT4oKTtcblxuICAgIC8qIENvbm5lY3RpbmcgdG8gSW5kZXhlZERCICovXG4gICAgdGhpcy5jb25uZWN0KHByZWZpeCk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIGl0ZW0gdmFsdWUgaW4gbG9jYWwgc3RvcmFnZVxuICAgKiBAcGFyYW0ga2V5IFRoZSBpdGVtJ3Mga2V5XG4gICAqIEByZXR1cm5zIFRoZSBpdGVtJ3MgdmFsdWUgaWYgdGhlIGtleSBleGlzdHMsIG51bGwgb3RoZXJ3aXNlLCB3cmFwcGVkIGluIGFuIFJ4SlMgT2JzZXJ2YWJsZVxuICAgKi9cbiAgZ2V0SXRlbTxUID0gYW55PihrZXk6IHN0cmluZyk6IE9ic2VydmFibGU8VMKgfCBudWxsPiB7XG5cbiAgICAvKiBGYWxsYmFjayBzdG9yYWdlIGlmIHNldCAqL1xuICAgIGlmICh0aGlzLmZhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5mYWxsYmFjay5nZXRJdGVtPFQ+KGtleSk7XG4gICAgfVxuXG4gICAgLyogT3BlbmluZyBhIHRyYXNhY3Rpb24gYW5kIHJlcXVlc3RpbmcgdGhlIGl0ZW0gaW4gbG9jYWwgc3RvcmFnZSAqL1xuICAgIHJldHVybiB0aGlzLmdldEl0ZW1Gcm9tVHJhbnNhY3Rpb248VD4oa2V5KTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEludGVybmFsIG1ldGhvZCB0byBmYWN0b3JpemUgdGhlIGdldHRlciBmb3IgZ2V0SXRlbSBhbmQgc2V0SXRlbSxcbiAgICogdGhlIGxhc3Qgb25lIG5lZWRpbmcgdG8gYmUgZnJvbSBhIHByZWV4aXN0aW5nIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBrZXkgVGhlIGl0ZW0ncyBrZXlcbiAgICogQHBhcmFtIHRyYW5zYWN0aW9uUGFyYW0gT3B0aW9uYWwgcHJlLWV4aXN0aW5nIHRyYW5zYWN0aW9uIHRvIHVzZSBmb3IgdGhlIHJlYWQgcmVxdWVzdFxuICAgKiBAcmV0dXJucyBUaGUgaXRlbSdzIHZhbHVlIGlmIHRoZSBrZXkgZXhpc3RzLCBudWxsIG90aGVyd2lzZSwgd3JhcHBlZCBpbiBhbiBSeEpTIE9ic2VydmFibGVcbiAgICovXG4gIHByaXZhdGUgZ2V0SXRlbUZyb21UcmFuc2FjdGlvbjxUID0gYW55PihrZXk6IHN0cmluZywgdHJhbnNhY3Rpb25QYXJhbT86IElEQk9iamVjdFN0b3JlKTogT2JzZXJ2YWJsZTxUwqB8IG51bGw+IHtcblxuICAgIGNvbnN0IHRyYW5zYWN0aW9uJCA9IHRyYW5zYWN0aW9uUGFyYW0gPyBvZih0cmFuc2FjdGlvblBhcmFtKSA6IHRoaXMudHJhbnNhY3Rpb24oKTtcblxuICAgIHJldHVybiB0cmFuc2FjdGlvbiQucGlwZShcbiAgICAgIG1hcCgodHJhbnNhY3Rpb24pID0+IHRyYW5zYWN0aW9uLmdldChrZXkpKSxcbiAgICAgIG1lcmdlTWFwKChyZXF1ZXN0KSA9PiB7XG5cbiAgICAgICAgLyogTGlzdGVuaW5nIHRvIHRoZSBzdWNjZXNzIGV2ZW50LCBhbmQgcGFzc2luZyB0aGUgaXRlbSB2YWx1ZSBpZiBmb3VuZCwgbnVsbCBvdGhlcndpc2UgKi9cbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9IChmcm9tRXZlbnQocmVxdWVzdCwgJ3N1Y2Nlc3MnKSBhcyBPYnNlcnZhYmxlPEV2ZW50PikucGlwZShcbiAgICAgICAgICBtYXAoKGV2ZW50KSA9PiAoZXZlbnQudGFyZ2V0IGFzIElEQlJlcXVlc3QpLnJlc3VsdCksXG4gICAgICAgICAgbWFwKChyZXN1bHQpID0+IHJlc3VsdCAmJiAodGhpcy5kYXRhUGF0aCBpbiByZXN1bHQpID8gKHJlc3VsdFt0aGlzLmRhdGFQYXRoXSBhcyBUKSA6IG51bGwpXG4gICAgICAgICk7XG5cbiAgICAgICAgLyogTWVyZ2luZyBzdWNjZXNzIGFuZCBlcnJvcnMgZXZlbnRzIGFuZCBhdXRvY2xvc2luZyB0aGUgb2JzZXJ2YWJsZSAqL1xuICAgICAgICByZXR1cm4gKHJhY2Uoc3VjY2VzcywgdGhpcy50b0Vycm9yT2JzZXJ2YWJsZShyZXF1ZXN0LCBgZ2V0dGVyYCkpKTtcbiAgICAgIH0pLFxuICAgICAgZmlyc3QoKVxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGFuIGl0ZW0gaW4gbG9jYWwgc3RvcmFnZVxuICAgKiBAcGFyYW0ga2V5IFRoZSBpdGVtJ3Mga2V5XG4gICAqIEBwYXJhbSBkYXRhIFRoZSBpdGVtJ3MgdmFsdWUsIG11c3QgTk9UIGJlIG51bGwgb3IgdW5kZWZpbmVkXG4gICAqIEByZXR1cm5zIEFuIFJ4SlMgT2JzZXJ2YWJsZSB0byB3YWl0IHRoZSBlbmQgb2YgdGhlIG9wZXJhdGlvblxuICAgKi9cbiAgc2V0SXRlbShrZXk6IHN0cmluZywgZGF0YTogYW55KTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG5cbiAgICAvKiBGYWxsYmFjayBzdG9yYWdlIGlmIHNldCAqL1xuICAgIGlmICh0aGlzLmZhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5mYWxsYmFjay5zZXRJdGVtKGtleSwgZGF0YSk7XG4gICAgfVxuXG4gICAgLyogU3RvcmluZyBudWxsIGlzIG5vdCBjb3JyZWN0bHkgc3VwcG9ydGVkIGJ5IEluZGV4ZWREQiBhbmQgdW5uZWNlc3NhcnkgaGVyZSAqL1xuICAgIGlmIChkYXRhID09IG51bGwpIHtcblxuICAgICAgcmV0dXJuIG9mKHRydWUpO1xuXG4gICAgfVxuXG4gICAgLyogVHJhbnNhY3Rpb24gbXVzdCBiZSB0aGUgc2FtZSBmb3IgcmVhZCBhbmQgd3JpdGUsIHRvIGF2b2lkIGNvbmN1cnJlbmN5IGlzc3VlcyAqL1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uJCA9IHRoaXMudHJhbnNhY3Rpb24oJ3JlYWR3cml0ZScpO1xuICAgIGxldCB0cmFuc2FjdGlvbjogSURCT2JqZWN0U3RvcmU7XG5cbiAgICAgICAgLyogT3BlbmluZyBhIHRyYW5zYWN0aW9uICovXG4gICAgICAgIHJldHVybiB0cmFuc2FjdGlvbiQucGlwZShcbiAgICAgICAgICB0YXAoKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbiA9IHZhbHVlO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIC8qIENoZWNrIGlmIHRoZSBrZXkgYWxyZWFkeSBleGlzdHMgb3Igbm90ICovXG4gICAgICAgICAgbWVyZ2VNYXAoKCkgPT4gdGhpcy5nZXRJdGVtRnJvbVRyYW5zYWN0aW9uKGtleSwgdHJhbnNhY3Rpb24pKSxcbiAgICAgICAgICBtYXAoKGV4aXN0aW5nRGF0YSkgPT4gKGV4aXN0aW5nRGF0YSA9PSBudWxsKSA/ICdhZGQnIDogJ3B1dCcpLFxuICAgICAgICAgIG1lcmdlTWFwKChtZXRob2QpID0+IHtcblxuICAgICAgICAgICAgbGV0IHJlcXVlc3Q6IElEQlJlcXVlc3Q7XG5cbiAgICAgICAgICAgIC8qIEFkZGluZyBvciB1cGRhdGluZyBsb2NhbCBzdG9yYWdlLCBiYXNlZCBvbiBwcmV2aW91cyBjaGVja2luZyAqL1xuICAgICAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgY2FzZSAnYWRkJzpcbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0gdHJhbnNhY3Rpb24uYWRkKHsgW3RoaXMuZGF0YVBhdGhdOiBkYXRhIH0sIGtleSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ3B1dCc6XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVxdWVzdCA9IHRyYW5zYWN0aW9uLnB1dCh7IFt0aGlzLmRhdGFQYXRoXTogZGF0YSB9LCBrZXkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKiBNZXJnaW5nIHN1Y2Nlc3MgKHBhc3NpbmcgdHJ1ZSkgYW5kIGVycm9yIGV2ZW50cyBhbmQgYXV0b2Nsb3NpbmcgdGhlIG9ic2VydmFibGUgKi9cbiAgICAgICAgICAgIHJldHVybiAocmFjZSh0aGlzLnRvU3VjY2Vzc09ic2VydmFibGUocmVxdWVzdCksIHRoaXMudG9FcnJvck9ic2VydmFibGUocmVxdWVzdCwgYHNldHRlcmApKSk7XG5cbiAgICAgICAgfSksXG4gICAgICAgIGZpcnN0KClcbiAgICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGFuIGl0ZW0gaW4gbG9jYWwgc3RvcmFnZVxuICAgKiBAcGFyYW0ga2V5IFRoZSBpdGVtJ3Mga2V5XG4gICAqIEByZXR1cm5zIEFuIFJ4SlMgT2JzZXJ2YWJsZSB0byB3YWl0IHRoZSBlbmQgb2YgdGhlIG9wZXJhdGlvblxuICAgKi9cbiAgcmVtb3ZlSXRlbShrZXk6IHN0cmluZyk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuXG4gICAgLyogRmFsbGJhY2sgc3RvcmFnZSBpZiBzZXQgKi9cbiAgICBpZiAodGhpcy5mYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMuZmFsbGJhY2sucmVtb3ZlSXRlbShrZXkpO1xuICAgIH1cblxuICAgIC8qIE9wZW5pbmcgYSB0cmFuc2FjdGlvbiBhbmQgY2hlY2tpbmcgaWYgdGhlIGl0ZW0gZXhpc3RzIGluIGxvY2FsIHN0b3JhZ2UgKi9cbiAgICByZXR1cm4gdGhpcy5nZXRJdGVtKGtleSkucGlwZShcbiAgICAgIG1lcmdlTWFwKChkYXRhKSA9PiB7XG5cbiAgICAgICAgLyogSWYgdGhlIGl0ZW0gZXhpc3RzIGluIGxvY2FsIHN0b3JhZ2UgKi9cbiAgICAgICAgaWYgKGRhdGEgIT0gbnVsbCkge1xuXG4gICAgICAgICAgLyogT3BlbmluZyBhIHRyYW5zYWN0aW9uICovXG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb24oJ3JlYWR3cml0ZScpLnBpcGUobWVyZ2VNYXAoKHRyYW5zYWN0aW9uKSA9PiB7XG5cbiAgICAgICAgICAgIC8qIERlbGV0aW5nIHRoZSBpdGVtIGluIGxvY2FsIHN0b3JhZ2UgKi9cbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0cmFuc2FjdGlvbi5kZWxldGUoa2V5KTtcblxuICAgICAgICAgICAgLyogTWVyZ2luZyBzdWNjZXNzIChwYXNzaW5nIHRydWUpIGFuZCBlcnJvciBldmVudHMgYW5kIGF1dG9jbG9zaW5nIHRoZSBvYnNlcnZhYmxlICovXG4gICAgICAgICAgICByZXR1cm4gKHJhY2UodGhpcy50b1N1Y2Nlc3NPYnNlcnZhYmxlKHJlcXVlc3QpLCB0aGlzLnRvRXJyb3JPYnNlcnZhYmxlKHJlcXVlc3QsIGByZW1vdmVyYCkpKTtcblxuICAgICAgICAgIH0pKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLyogUGFzc2luZyB0cnVlIGlmIHRoZSBpdGVtIGRvZXMgbm90IGV4aXN0IGluIGxvY2FsIHN0b3JhZ2UgKi9cbiAgICAgICAgcmV0dXJuIG9mKHRydWUpO1xuXG4gICAgICB9KSxcbiAgICAgIGZpcnN0KClcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBhbGwgaXRlbXMgZnJvbSBsb2NhbCBzdG9yYWdlXG4gICAqIEByZXR1cm5zIEFuIFJ4SlMgT2JzZXJ2YWJsZSB0byB3YWl0IHRoZSBlbmQgb2YgdGhlIG9wZXJhdGlvblxuICAgKi9cbiAgY2xlYXIoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG5cbiAgICAvKiBGYWxsYmFjayBzdG9yYWdlIGlmIHNldCAqL1xuICAgIGlmICh0aGlzLmZhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5mYWxsYmFjay5jbGVhcigpO1xuICAgIH1cblxuICAgIC8qIE9wZW5pbmcgYSB0cmFuc2FjdGlvbiAqL1xuICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uKCdyZWFkd3JpdGUnKS5waXBlKFxuICAgICAgbWVyZ2VNYXAoKHRyYW5zYWN0aW9uKSA9PiB7XG5cbiAgICAgICAgLyogRGVsZXRpbmcgYWxsIGl0ZW1zIGZyb20gbG9jYWwgc3RvcmFnZSAqL1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdHJhbnNhY3Rpb24uY2xlYXIoKTtcblxuICAgICAgICAvKiBNZXJnaW5nIHN1Y2Nlc3MgKHBhc3NpbmcgdHJ1ZSkgYW5kIGVycm9yIGV2ZW50cyBhbmQgYXV0b2Nsb3NpbmcgdGhlIG9ic2VydmFibGUgKi9cbiAgICAgICAgcmV0dXJuIChyYWNlKHRoaXMudG9TdWNjZXNzT2JzZXJ2YWJsZShyZXF1ZXN0KSwgdGhpcy50b0Vycm9yT2JzZXJ2YWJsZShyZXF1ZXN0LCBgY2xlYXJlcmApKSk7XG5cbiAgICAgIH0pLFxuICAgICAgZmlyc3QoKVxuICAgICk7XG5cbiAgfVxuXG4gIGtleXMoKTogT2JzZXJ2YWJsZTxzdHJpbmdbXT4ge1xuXG4gICAgLyogRmFsbGJhY2sgc3RvcmFnZSBpZiBzZXQgKi9cbiAgICBpZiAodGhpcy5mYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMuZmFsbGJhY2sua2V5cygpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uKCdyZWFkb25seScpLnBpcGUoXG4gICAgICBtZXJnZU1hcCgodHJhbnNhY3Rpb24pID0+IHtcblxuICAgICAgICAvKiBEZWxldGluZyB0aGUgaXRlbSBpbiBsb2NhbCBzdG9yYWdlICovXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0cmFuc2FjdGlvbi5nZXRBbGxLZXlzKCk7XG5cbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9IChmcm9tRXZlbnQocmVxdWVzdCwgJ3N1Y2Nlc3MnKSBhcyBPYnNlcnZhYmxlPEV2ZW50PikucGlwZShcbiAgICAgICAgICBtYXAoKGV2ZW50KSA9PiAoZXZlbnQudGFyZ2V0IGFzIElEQlJlcXVlc3QpLnJlc3VsdCBhcyBzdHJpbmdbXSlcbiAgICAgICAgKTtcblxuICAgICAgICAvKiBNZXJnaW5nIHN1Y2Nlc3MgYW5kIGVycm9ycyBldmVudHMgYW5kIGF1dG9jbG9zaW5nIHRoZSBvYnNlcnZhYmxlICovXG4gICAgICAgIHJldHVybiAocmFjZShzdWNjZXNzLCB0aGlzLnRvRXJyb3JPYnNlcnZhYmxlKHJlcXVlc3QsIGBrZXlzYCkpKTtcblxuICAgICAgfSksXG4gICAgICBmaXJzdCgpXG4gICAgKTtcblxuICB9XG5cbiAgaGFzKGtleTogc3RyaW5nKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG5cbiAgICAvKiBGYWxsYmFjayBzdG9yYWdlIGlmIHNldCAqL1xuICAgIGlmICh0aGlzLmZhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5mYWxsYmFjay5oYXMoa2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbigncmVhZG9ubHknKS5waXBlKFxuICAgICAgbWFwKCh0cmFuc2FjdGlvbikgPT4gdHJhbnNhY3Rpb24uZ2V0S2V5KGtleSkpLFxuICAgICAgbWVyZ2VNYXAoKHJlcXVlc3QpID0+IHtcblxuICAgICAgICAvKiBMaXN0ZW5pbmcgdG8gdGhlIHN1Y2Nlc3MgZXZlbnQsIGFuZCBwYXNzaW5nIHRoZSBpdGVtIHZhbHVlIGlmIGZvdW5kLCBudWxsIG90aGVyd2lzZSAqL1xuICAgICAgICBjb25zdCBzdWNjZXNzID0gKGZyb21FdmVudChyZXF1ZXN0LCAnc3VjY2VzcycpIGFzIE9ic2VydmFibGU8RXZlbnQ+KS5waXBlKFxuICAgICAgICAgIG1hcCgoZXZlbnQpID0+IChldmVudC50YXJnZXQgYXMgSURCUmVxdWVzdCkucmVzdWx0KSxcbiAgICAgICAgICBtYXAoKHJlc3VsdCkgPT4gKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSA/IHRydWUgOiBmYWxzZSlcbiAgICAgICAgKTtcblxuICAgICAgICAvKiBNZXJnaW5nIHN1Y2Nlc3MgYW5kIGVycm9ycyBldmVudHMgYW5kIGF1dG9jbG9zaW5nIHRoZSBvYnNlcnZhYmxlICovXG4gICAgICAgIHJldHVybiAocmFjZShzdWNjZXNzLCB0aGlzLnRvRXJyb3JPYnNlcnZhYmxlKHJlcXVlc3QsIGBoYXNgKSkpO1xuICAgICAgfSksXG4gICAgICBmaXJzdCgpXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIENvbm5lY3RzIHRvIEluZGV4ZWREQiBhbmQgY3JlYXRlcyB0aGUgb2JqZWN0IHN0b3JlIG9uIGZpcnN0IHRpbWVcbiAgICovXG4gIHByb3RlY3RlZCBjb25uZWN0KHByZWZpeDogc3RyaW5nIHwgbnVsbCA9IG51bGwpOiB2b2lkIHtcblxuICAgIGxldCByZXF1ZXN0OiBJREJPcGVuREJSZXF1ZXN0O1xuXG4gICAgLyogQ29ubmVjdGluZyB0byBJbmRleGVkREIgKi9cbiAgICB0cnkge1xuXG4gICAgICByZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4odGhpcy5kYk5hbWUpO1xuXG4gICAgfcKgY2F0Y2ggKGVycm9yKSB7XG5cbiAgICAgIC8qIEZhbGxiYWNrIHN0b3JhZ2UgaWYgSW5kZXhlZERiIGNvbm5lY3Rpb24gaXMgZmFpbGluZyAqL1xuICAgICAgdGhpcy5zZXRGYWxsYmFjayhwcmVmaXgpO1xuXG4gICAgICByZXR1cm47XG5cbiAgICB9XG5cbiAgICAvKiBMaXN0ZW5pbmcgdGhlIGV2ZW50IGZpcmVkIG9uIGZpcnN0IGNvbm5lY3Rpb24sIGNyZWF0aW5nIHRoZSBvYmplY3Qgc3RvcmUgZm9yIGxvY2FsIHN0b3JhZ2UgKi9cbiAgICAoZnJvbUV2ZW50KHJlcXVlc3QsICd1cGdyYWRlbmVlZGVkJykgYXMgT2JzZXJ2YWJsZTxFdmVudD4pXG4gICAgICAucGlwZShmaXJzdCgpKVxuICAgICAgLnN1YnNjcmliZSgoZXZlbnQpID0+IHtcblxuICAgICAgICAvKiBHZXR0aW5nIHRoZSBkYXRhYmFzZSBjb25uZWN0aW9uICovXG4gICAgICAgIGNvbnN0IGRhdGFiYXNlID0gKGV2ZW50LnRhcmdldCBhcyBJREJSZXF1ZXN0KS5yZXN1bHQgYXMgSURCRGF0YWJhc2U7XG5cbiAgICAgICAgLyogQ2hlY2tpbmcgaWYgdGhlIG9iamVjdCBzdG9yZSBhbHJlYWR5IGV4aXN0cywgdG8gYXZvaWQgZXJyb3IgKi9cbiAgICAgICAgaWYgKCFkYXRhYmFzZS5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKHRoaXMub2JqZWN0U3RvcmVOYW1lKSkge1xuXG4gICAgICAgICAgLyogQ3JlYXRpbmcgdGhlIG9iamVjdCBzdG9yZSBmb3IgbG9jYWwgc3RvcmFnZSAqL1xuICAgICAgICAgIGRhdGFiYXNlLmNyZWF0ZU9iamVjdFN0b3JlKHRoaXMub2JqZWN0U3RvcmVOYW1lKTtcblxuICAgICAgICB9XG5cbiAgICAgIH0pO1xuXG4gICAgLyogTGlzdGVuaW5nIHRoZSBzdWNjZXNzIGV2ZW50IGFuZCBjb252ZXJ0aW5nIHRvIGFuIFJ4SlMgT2JzZXJ2YWJsZSAqL1xuICAgIGNvbnN0IHN1Y2Nlc3MgPSBmcm9tRXZlbnQocmVxdWVzdCwgJ3N1Y2Nlc3MnKSBhcyBPYnNlcnZhYmxlPEV2ZW50PjtcblxuICAgIC8qIE1lcmdpbmcgc3VjY2VzcyBhbmQgZXJyb3JzIGV2ZW50cyAqL1xuICAgIChyYWNlKHN1Y2Nlc3MsIHRoaXMudG9FcnJvck9ic2VydmFibGUocmVxdWVzdCwgYGNvbm5lY3Rpb25gKSkgYXMgT2JzZXJ2YWJsZTxFdmVudD4pXG4gICAgICAucGlwZShmaXJzdCgpKVxuICAgICAgLnN1YnNjcmliZSgoZXZlbnQpID0+IHtcblxuICAgICAgICAvKiBTdG9yaW5nIHRoZSBkYXRhYmFzZSBjb25uZWN0aW9uIGZvciBmdXJ0aGVyIGFjY2VzcyAqL1xuICAgICAgICB0aGlzLmRhdGFiYXNlLm5leHQoKGV2ZW50LnRhcmdldCBhcyBJREJSZXF1ZXN0KS5yZXN1bHQgYXMgSURCRGF0YWJhc2UpO1xuXG4gICAgICB9LCAoKSA9PiB7XG5cbiAgICAgICAgLyogRmFsbGJhY2sgc3RvcmFnZSBpZiBJbmRleGVkRGIgY29ubmVjdGlvbiBpcyBmYWlsaW5nICovXG4gICAgICAgIHRoaXMuc2V0RmFsbGJhY2socHJlZml4KTtcblxuICAgICAgfSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVucyBhbiBJbmRleGVkREIgdHJhbnNhY3Rpb24gYW5kIGdldHMgdGhlIGxvY2FsIHN0b3JhZ2Ugb2JqZWN0IHN0b3JlXG4gICAqIEBwYXJhbSBtb2RlIERlZmF1bHQgdG8gJ3JlYWRvbmx5JyBmb3IgcmVhZCBvcGVyYXRpb25zLCBvciAncmVhZHdyaXRlJyBmb3Igd3JpdGUgb3BlcmF0aW9uc1xuICAgKiBAcmV0dXJucyBBbiBJbmRleGVkREIgdHJhbnNhY3Rpb24gb2JqZWN0IHN0b3JlLCB3cmFwcGVkIGluIGFuIFJ4SlMgT2JzZXJ2YWJsZVxuICAgKi9cbiAgcHJvdGVjdGVkIHRyYW5zYWN0aW9uKG1vZGU6ICdyZWFkb25seScgfCAncmVhZHdyaXRlJyA9ICdyZWFkb25seScpOiBPYnNlcnZhYmxlPElEQk9iamVjdFN0b3JlPiB7XG5cbiAgICAvKiBGcm9tIHRoZSBJbmRleGVkREIgY29ubmVjdGlvbiwgb3BlbmluZyBhIHRyYW5zYWN0aW9uIGFuZCBnZXR0aW5nIHRoZSBsb2NhbCBzdG9yYWdlIG9iamV0IHN0b3JlICovXG4gICAgcmV0dXJuIHRoaXMuZGF0YWJhc2VcbiAgICAgIC5waXBlKG1hcCgoZGF0YWJhc2UpID0+IGRhdGFiYXNlLnRyYW5zYWN0aW9uKFt0aGlzLm9iamVjdFN0b3JlTmFtZV0sIG1vZGUpLm9iamVjdFN0b3JlKHRoaXMub2JqZWN0U3RvcmVOYW1lKSkpO1xuXG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyBhIEluZGV4ZWREQiBzdWNjZXNzIGV2ZW50IGluIGFuIFJ4SlMgT2JzZXJ2YWJsZVxuICAgKiBAcGFyYW0gcmVxdWVzdCBUaGUgcmVxdWVzdCB0byBsaXN0ZW5cbiAgICogQHJldHVybnMgQSBSeEpTIE9ic2VydmFibGUgd2l0aCB0cnVlIHZhbHVlXG4gICAqL1xuICBwcm90ZWN0ZWQgdG9TdWNjZXNzT2JzZXJ2YWJsZShyZXF1ZXN0OiBJREJSZXF1ZXN0KTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG5cbiAgICAvKiBUcmFuc2Zvcm1pbmcgYSBJbmRleGVkREIgc3VjY2VzcyBldmVudCBpbiBhbiBSeEpTIE9ic2VydmFibGUgd2l0aCB0cnVlIHZhbHVlICovXG4gICAgcmV0dXJuIChmcm9tRXZlbnQocmVxdWVzdCwgJ3N1Y2Nlc3MnKSBhcyBPYnNlcnZhYmxlPEV2ZW50PilcbiAgICAgIC5waXBlKG1hcCgoKSA9PiB0cnVlKSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIGEgSW5kZXhlZERCIGVycm9yIGV2ZW50IGluIGFuIFJ4SlMgRXJyb3JPYnNlcnZhYmxlXG4gICAqIEBwYXJhbSByZXF1ZXN0IFRoZSByZXF1ZXN0IHRvIGxpc3RlblxuICAgKiBAcGFyYW0gZXJyb3IgT3B0aW9ubmFsIGRldGFpbHMgYWJvdXQgdGhlIGVycm9yJ3Mgb3JpZ2luXG4gICAqIEByZXR1cm5zIEEgUnhKUyBFcnJvck9ic2VydmFibGVcbiAgICovXG4gIHByb3RlY3RlZCB0b0Vycm9yT2JzZXJ2YWJsZShyZXF1ZXN0OiBJREJSZXF1ZXN0LCBlcnJvciA9IGBgKTogT2JzZXJ2YWJsZTxuZXZlcj4ge1xuXG4gICAgLyogVHJhbnNmb3JtaW5nIGEgSW5kZXhlZERCIGVycm9yIGV2ZW50IGluIGFuIFJ4SlMgRXJyb3JPYnNlcnZhYmxlICovXG4gICAgcmV0dXJuIChmcm9tRXZlbnQocmVxdWVzdCwgJ2Vycm9yJykgYXMgT2JzZXJ2YWJsZTxFdmVudD4pXG4gICAgICAucGlwZShcbiAgICAgICAgbWVyZ2VNYXAoKCkgPT4gdGhyb3dFcnJvcihuZXcgRXJyb3IoYEluZGV4ZWREQiAke2Vycm9yfSBpc3N1ZSA6ICR7KHJlcXVlc3QuZXJyb3IgYXMgRE9NRXhjZXB0aW9uKS5tZXNzYWdlfS5gKSkpXG4gICAgICApO1xuXG4gIH1cblxuICBwcm90ZWN0ZWQgc2V0RmFsbGJhY2socHJlZml4OiBzdHJpbmcgfCBudWxsKTogdm9pZCB7XG4gICAgdGhpcy5mYWxsYmFjayA9IG5ldyBMb2NhbFN0b3JhZ2VEYXRhYmFzZShwcmVmaXgpO1xuICB9XG5cbn1cbiJdfQ==